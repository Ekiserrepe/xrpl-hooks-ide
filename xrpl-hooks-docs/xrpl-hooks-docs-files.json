[{"code":"hooks-account-buf-len","markdown":"hooks-account-buf-len\n---\n\nFunction `hook_account` has fixed-size account ID output.\n\nThis check warns about too-small size of its output buffer (if it's\nspecified by a constant - variable parameter is ignored).\n\n"},{"code":"hooks-account-conv-buf-len","markdown":"hooks-account-conv-buf-len\n---\n\nFunction `util_raddr` has fixed-size account ID input.\n\nThis check warns unless the correct size is passed in the input size\nparameter (if it's specified by a constant - variable parameter is\nignored).\n"},{"code":"hooks-account-conv-pure","markdown":"hooks-account-conv-pure\n---\n\nHooks identify accounts by the 20 byte account ID, which can be\nconverted to an raddr using the `util_raddr` function. If the account\nID never changes, a more efficient way to do this is precompute the\nraddr from the account ID.\n\nThis check warns about calls of `util_raddr` with constant input and\nproposes to add a tracing statement showing the computed value (so\nthat the user can use it to replace the call).\n"},{"code":"hooks-array-buf-len","markdown":"hooks-array-buf-len\n---\n\nHook API `sto_subarray` requires non-empty input buffer and takes a\nparameter specifying the array index, whose value is limited - the\nsought object cannot be found if the limit is exceeded.\n\nThis check warns about empty input as well as too-large values of the\nindex specified in calls to `sto_subarray` (if they're specified by\nconstants - variable parameters are ignored).\n"},{"code":"hooks-burden-prereq","markdown":"hooks-burden-prereq\n---\n\nHook API `etxn_burden` computes transaction burden, based on (i.a.)\nthe number of reserved transactions, so a call to it must be preceded\nby a call to `etxn_reserve`.\n"},{"code":"hooks-detail-buf-len","markdown":"hooks-detail-buf-len\n---\n\nFunction `etxn_details` has fixed-size sfEmitDetails output.\n\nThis check warns about too-small size of its output buffer (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-detail-prereq","markdown":"hooks-detail-prereq\n---\n\nHook API `etxn_details` serializes emit details, based on (i.a.) the\nnumber of reserved transactions, so a call to it must be preceded by a\ncall to `etxn_reserve`.\n"},{"code":"hooks-emit-buf-len","markdown":"hooks-emit-buf-len\n---\n\nFunction `emit` has fixed-size transaction hash output.\n\nThis check warns about too-small size of its output buffer (if it's\nspecified by a constant - variable parameter is ignored).\n\n"},{"code":"hooks-emit-prereq","markdown":"hooks-emit-prereq\n---\n\nBefore emitting a transaction using `emit` Hook API, a hook must set a\nmaximal count of transactions it plans to emit, by calling\n`etxn_reserve`.\n"},{"code":"hooks-entry-point-recursion","markdown":"hooks-entry-point-recursion\n---\n\nRecursive calls are disallowed in the implementation of hook entry\npoints.\n"},{"code":"hooks-entry-points-neg","markdown":"hooks-entry-points-neg\n---\n\nShows error on function definitions with unexpected (that is, neither\n`hook` nor `cbak`) names.\n"},{"code":"hooks-entry-points","markdown":"hooks-entry-points\n---\n\n1. Hook always implements and exports exactly two functions: `cbak` and\n   `hook`.\n   \n\nThis check shows error on translation units that do not have them.\n"},{"code":"hooks-fee-prereq","markdown":"hooks-fee-prereq\n---\n\nHook API `etxn_fee_base` estimates a transaction fee, based on (i.a.)\nthe number of reserved transactions, so a call to it must be preceded\nby a call to `etxn_reserve`.\n"},{"code":"hooks-field-add-buf-len","markdown":"hooks-field-add-buf-len\n---\n\nEmplacing a new field into STObject by calling `sto_emplace` requires\nenough space to serialize the new STObject into; the API also limits\nsizes of the old object and field.\n\nThis check warns about insufficient output buffer space as well as\ntoo-large values of the inputs in calls to `sto_emplace` (if they're\nspecified by constants - variable parameters are ignored).\n"},{"code":"hooks-field-buf-len","markdown":"hooks-field-buf-len\n---\n\nHook API `sto_subfield` requires non-empty input buffer.\n\nThis check warns about empty input in calls to `sto_subfield` (if it's\nspecified by a constant - variable parameter is ignored).\n\n"},{"code":"hooks-field-del-buf-len","markdown":"hooks-field-del-buf-len\n---\n\nErasing a field from STObject by calling `sto_erase` requires enough\nspace to serialize the new STObject into; the API also limits size of\nthe old object.\n\nThis check warns about insufficient output buffer space as well as\ntoo-large value of the input STObject in calls to `sto_erase` (if\nthey're specified by constants - variable parameters are ignored).\n"},{"code":"hooks-float-arith-pure","markdown":"hooks-float-arith-pure\n---\n\nHooks can compute floating-point values in XFL format by calling\nfunctions `float_multiply`, `float_mulratio`, `float_negate`,\n`float_sum`, `float_invert` and `float_divide` and access their\nconstituent parts by calling `float_exponent`, `float_mantissa` and\n`float_sign`. If the inputs of the computation never change, a more\nefficient way to do this is to precompute it.\n\nThis check warns about calls of the aforementioned functions with\nconstant inputs and in simple cases proposes to add a tracing\nstatement showing the computed value (so that the user can use it to\nreplace the call). It also checks that the divisor passed to\n`float_divide`, `float_mulratio` and `float_invert` is not 0 (if it's\nspecified by a constant - variable parameters are ignored).\n"},{"code":"hooks-float-compare-pure","markdown":"hooks-float-compare-pure\n---\n\nHooks can compare floating-point values in XFL format by calling the\n`float_compare` function. If the inputs of the comparison never\nchange, its result is fixed and the function need not be called.\n\nThis check warns about calls of `float_compare` with constant inputs\nas well as invalid values of the comparison mode parameter (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-float-int-pure","markdown":"hooks-float-int-pure\n---\n\nHooks can convert floating-point values in XFL format to integers by\ncalling the `float_int` function. If the inputs of this function never\nchange, a more efficient way to do this is to precompute the integer\nvalue.\n\nThis check warns about calls of `float_int` with constant inputs as\nwell as invalid values of the decimal places parameter (if it's\nspecified by a constant - variable parameter is ignored).\n\n"},{"code":"hooks-float-manip-pure","markdown":"hooks-float-manip-pure\n---\n\nHooks can directly manipulate floating-point values in XFL format by\ncalling functions `float_exponent_set`, `float_mantissa_set` and\n`float_sign_set`. If the inputs of the update never change, a more\nefficient way to do this is to precompute it.\n\nThis check warns about calls of the aforementioned functions with\nconstant inputs and in simple cases proposes to add a tracing\nstatement showing the computed value (so that the user can use it to\nreplace the call). It also checks documented bounds of the second\nparameter of these functions (if it's specified by a constant -\nvariable parameter is ignored).\n"},{"code":"hooks-float-one-pure","markdown":"hooks-float-one-pure\n---\n\nHooks can obtain XFL enclosing number 1 by calling the float_one\n1. Since the number never changes, a more efficient way is to\n   use its precomputed value.\n\n"},{"code":"hooks-float-pure","markdown":"hooks-float-pure\n---\n\nHooks can use floating-point values in XFL format, creating them from\nmantissa and exponent by calling the `float_set` function. If the\nmantissa and exponent never change, a more efficient way to do this is\nto precompute the floating-point value.\n\nThis check warns about calls of `float_set` with constant inputs and\nproposes to add a tracing statement showing the computed value (so\nthat the user can use it to replace the call). In the special case of\n1. mantissa and 0 exponent (\"canonical 0\"), a replacement value of 0 is\n   proposed directly, with no need to trace it.\n\n"},{"code":"hooks-guard-called","markdown":"hooks-guard-called\n---\n\nEvery hook needs to import the guard function `_g` and use it at least once.\n"},{"code":"hooks-guard-in-for","markdown":"hooks-guard-in-for\n---\n\nConsider the following for-loop in C:\n\n<dl>\n  <dt>  #define GUARD(maxiter) _g(__LINE__, (maxiter)+1)</dt>\n  <dd>\n    <p>#define GUARD(maxiter) _g(__LINE__, (maxiter)+1)</p>\n    <p>for (int i = 0; GUARD(3), i < 3; ++i)</p>\n  </dd>\n</dl>\nThis is the only way to satisfy the guard rule when using a for-loop\nin C.\n"},{"code":"hooks-guard-in-while","markdown":"hooks-guard-in-while\n---\n\nLike for loops, while loops must have a guard in their condition:\n\n<dl>\n  <dt>  #define GUARD(maxiter) _g(__LINE__, (maxiter)+1)</dt>\n  <dd>\n    <p>#define GUARD(maxiter) _g(__LINE__, (maxiter)+1)</p>\n    <p>int i = 0;</p>\n    <p>while (GUARD(3), i < 3)</p>\n  </dd>\n</dl>\n"},{"code":"hooks-hash-buf-len","markdown":"hooks-hash-buf-len\n---\n\nFunctions `util_sha512h`, `hook_hash`, `ledger_last_hash` and `nonce`\nhave fixed-size hash output.\n\nThis check warns about too-small size of their output buffer (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-keylet-buf-len","markdown":"hooks-keylet-buf-len\n---\n\nComputing a ripple keylet by calling `util_keylet` requires valid\nparameters dependent on the keylet type.\n\nThis check does not fully parse these parameters, but warns about\ninvalid keylet type as well as buffer sizes that cannot be valid (if\nthey're specified by constants - variable parameters are ignored).\n"},{"code":"hooks-raddr-conv-buf-len","markdown":"hooks-raddr-conv-buf-len\n---\n\nHook API `util_accid` has upper limit on the length of its input\n(because it expects it to be a raddr) and fixed-size account ID\noutput.\n\nThis check warns about invalid sizes of input and output parameters\n(if they're specified by constants - variable parameters are ignored).\n"},{"code":"hooks-raddr-conv-pure","markdown":"hooks-raddr-conv-pure\n---\n\nHooks identify accounts by the 20 byte account ID, which can be\nconverted from a raddr using the `util_accid` function. If the raddr\nnever changes, a more efficient way to do this is precompute the\naccount-id from the raddr.\n\nThis check warns about calls of `util_accid` with constant input and\nproposes to add a tracing statement showing the computed value (so\nthat the user can use it to replace the call).\n"},{"code":"hooks-reserve-limit","markdown":"hooks-reserve-limit\n---\n\nHook API `etxn_reserve` takes a parameter specifying the number of\ntransactions intended to emit from the calling hook. Value of this\nparameter is limited, and the function fails if the limit is exceeded.\n\nThis check warns about too-large values of the number of reserved\ntransactions (if they're specified by a constant - variable parameter\nis ignored).\n"},{"code":"hooks-slot-hash-buf-len","markdown":"hooks-slot-hash-buf-len\n---\n\nFunction `slot_id` has fixed-size canonical hash output.\n\nThis check warns about too-small size of its output buffer as well as\ninvalid values of the slot number parameter (if they're specified by\nconstants - variable parameters are ignored).\n"},{"code":"hooks-slot-keylet-buf-len","markdown":"hooks-slot-keylet-buf-len\n---\n\nFunction `slot_set` has structured keylet input.\n\nThis check does not parse the input, but warns about its sizes that\ncannot be valid as well as invalid values of the slot number parameter\n(if they're specified by constants - variable parameters are ignored).\n"},{"code":"hooks-slot-limit","markdown":"hooks-slot-limit\n---\n\nHook APIs `slot`, `slot_count`, `slot_clear`, `slot_size`,\n`slot_float` and `trace_slot` take a parameter specifying the accessed\nslot number. Value of this parameter is limited, and the functions\nfail if the limit is exceeded.\n\nThis check warns about too-large values of the slot number (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-slot-sub-limit","markdown":"hooks-slot-sub-limit\n---\n\nHook APIs `slot_subarray` and `slot_subfield` take parameters\nspecifying parent and child slot numbers. Values of these parameters\nare limited, and the functions fail if the limit is exceeded.\n\nThis check warns about too-large values of the slot numbers (if\nthey're specified by a constant - variable parameters are ignored).\n"},{"code":"hooks-slot-type-limit","markdown":"hooks-slot-type-limit\n---\n\nHook API `slot_type` takes a parameter specifying the accessed slot\n1. Value of this parameter is limited, and the function fails if\n   the limit is exceeded.\n   \n\nThis check warns about too-large values of the slot number as well as\ninvalid values of the flags parameter (if they're specified by\nconstants - variable parameters are ignored).\n"},{"code":"hooks-state-buf-len","markdown":"hooks-state-buf-len\n---\n\nFunctions state and state_set accept fixed-size Hook State key.\n\nThis check warns about invalid size of its input buffer (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-transaction-hash-buf-len","markdown":"hooks-transaction-hash-buf-len\n---\n\nFunction `otxn_id` has fixed-size canonical hash output.\n\nThis check warns about too-small size of its output buffer (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-transaction-slot-limit","markdown":"hooks-transaction-slot-limit\n---\n\nFunction `otxn_slot` takes a parameter specifying the accessed slot\n1. Value of this parameter is limited, and the function fails if\n   the limit is exceeded.\n   \n\nThis check warns about too-large values of the slot number (if it's\nspecified by a constant - variable parameter is ignored).\n"},{"code":"hooks-validate-buf-len","markdown":"hooks-validate-buf-len\n---\n\nHook API `sto_validate` requires non-empty input buffer.\n\nThis check warns about empty input in calls to `sto_validate` (if it's\nspecified by a constant - variable parameter is ignored).\n\n"},{"code":"hooks-verify-buf-len","markdown":"hooks-verify-buf-len\n---\n\nVerifying a cryptographic signature by calling `util_verify` requires\nvalid public key & data signature.\n\nThis check does not fully parse these parameters, but warns about\ntheir sizes that cannot be valid (if they're specified by constants -\nvariable parameters are ignored).\n\n"}]